# SYNK AI 캐릭터 챗 — 응답 파이프라인 전체 흐름

> 유저가 메시지를 보내면, AI가 어떤 과정을 거쳐서 답변하는지 한눈에 보여주는 문서

---

## 전체 흐름 요약

```
유저 메시지 입력
     ↓
① 검증 & 인증
     ↓
② 컨텍스트 수집 (병렬 처리)
   ├─ 대화 히스토리 (최근 30개)
   ├─ 로어북 필터링
   ├─ 캐릭터별 기억 검색
   ├─ 유저 페르소나
   └─ 현재 장면 정보
     ↓
③ 프롬프트 조립
   ├─ systemInstruction (고정, 캐싱됨)
   └─ contents (매 턴마다 동적 생성)
     ↓
④ Gemini API 스트리밍 호출
     ↓
⑤ 응답 파싱 & DB 저장
   ├─ 나레이션 턴 → Message 저장
   ├─ 캐릭터 대사 턴 → Message 저장
   └─ SSE 이벤트로 클라이언트에 실시간 전송
     ↓
⑥ 메모리 후처리
   ├─ 관계도 업데이트 (5축 모델)
   ├─ 유저 팩트 추출 & 충돌 해결
   ├─ 캐릭터 기억 저장 (놀라움 기반 필터)
   └─ 감정 히스토리 누적
     ↓
⑦ 세션 업데이트
     ↓
⑧ 백그라운드 작업 (비동기)
   ├─ 5턴마다 대화 요약 생성
   ├─ 기억 통합 & 승격
   └─ (선택) 이미지 생성
```

---

## ① 검증 & 인증

**파일:** `src/app/api/chat/route.ts` (PUT 핸들러)

유저가 메시지를 보내면 가장 먼저 일어나는 일이야.

- 로그인 상태 확인 (NextAuth 세션 체크)
- 메시지 길이 검증 (최대 5,000자)
- `sessionId`로 채팅 세션 조회

통과하면 본격적으로 AI 응답 생성 시작!

---

## ② 컨텍스트 수집 — "AI한테 뭘 알려줄까?"

**파일:** `src/lib/chat-service.ts` → `buildChatContext()`

AI가 좋은 답변을 하려면 **지금 상황을 잘 알아야** 하잖아? 그래서 여러 정보를 **동시에(병렬로)** 가져와.

### 2-1. 대화 히스토리

**파일:** `src/lib/prompt-builder.ts`

두 가지 전략이 있어:

**전략 A: 선택적 히스토리** (임베딩이 있을 때)
- 유저 메시지와 의미적으로 비슷한 과거 대화를 코사인 유사도로 검색
- `[관련 과거 대화]` + `[최근 대화]` 두 섹션으로 구성
- 예전에 나눈 중요한 대화를 AI가 "기억"하는 것처럼 동작

**전략 B: 최근 대화만** (임베딩 없을 때)
- 최근 30개 메시지를 그대로 포맷팅
- 토큰 제한: 50,000 토큰
- 메시지 포맷:
  - 나레이션 → `[상황 묘사] {내용}`
  - 유저 → `{유저이름}의 행동: {내용}`
  - 캐릭터 → `{캐릭터이름}의 반응: {내용}`

### 2-2. 로어북 필터링

**파일:** `src/lib/prompt-builder.ts` → `filterActiveLorebookEntries()`

로어북 항목이 활성화되려면 **4가지 조건**을 모두 만족해야 해:

| 조건 | 설명 |
|------|------|
| 키워드 매칭 | 대화 내용에 키워드가 포함되어 있는지 |
| 최소 친밀도 | 캐릭터와 충분히 친해졌는지 |
| 최소 턴 수 | 대화를 충분히 나눴는지 |
| 필수 캐릭터 | 해당 캐릭터가 현재 장면에 있는지 |

재미있는 점: **연쇄 활성화**가 가능해! (최대 3라운드) → 항목 A가 활성화되면, A의 내용에 있는 키워드가 항목 B를 트리거할 수 있음.

### 2-3. 캐릭터 기억 조립

**파일:** `src/lib/narrative-memory.ts` → `buildNarrativeContext()`

장면에 있는 **각 캐릭터마다** 기억을 조립해:

**관계 상태 로딩** (크로스 세션, userId+workId 범위)
- 친밀도 레벨: stranger → acquaintance → friend → close_friend → intimate
- 5축 모델: 신뢰 / 애정 / 존경 / 경쟁심 / 친숙도 (각 0~100)
- 알고 있는 사실, 공유한 경험, 말투 스타일

**시맨틱 메모리 검색**
- 유저 메시지를 임베딩 벡터로 변환
- CharacterMemory DB에서 코사인 유사도 검색
- 상위 10개 기억을 가중치로 순위 매김:
  - 유사도 70% + 중요도 20% + 강도 10%

**프롬프트 배치 전략: "Lost-in-the-Middle" 방지**
- [상단] 관계 상태 (친밀도, 5축 수치)
- [중간] 최근 순간들, 기억, 감정
- [하단] 정체성 사실 (유저 메시지에 가장 가까이)

> AI 모델이 프롬프트 중간 부분을 잘 못 읽는 문제를 해결하기 위한 배치야!

### 2-4. 유저 페르소나 & 장면 정보

- 유저 페르소나: 이름, 나이, 성별, 설명
- 현재 장면: 위치, 시간, 참여 캐릭터 목록

---

## ③ 프롬프트 조립 — "AI에게 보내는 최종 지시서"

**파일:** `src/lib/gemini.ts` → `buildSystemInstruction()` + `buildContents()`

프롬프트는 **두 레이어**로 나뉘어:

### systemInstruction (고정 레이어, 캐싱됨)

한 번 만들면 같은 작품 내에서 재사용되는 부분:

```
┌─────────────────────────────────────┐
│  응답 규칙                            │
│  ├─ 유저 행동 존중, 서사 연속성 유지     │
│  ├─ 턴 구성: 나레이터 + 대사 교환       │
│  ├─ 장면 전개: 긴장감 있게 끝내기       │
│  ├─ 나레이터 기법: 환경, 감각, 행동     │
│  ├─ 대사 규칙: 2~4문장, 반복 금지      │
│  └─ 표정 유형: 8가지                  │
├─────────────────────────────────────┤
│  세계관 설정 (work.worldSetting)       │
├─────────────────────────────────────┤
│  캐릭터 페르소나 (전체)                │
│  ├─ {{user}} → 유저 이름으로 치환      │
│  └─ {{char}} → 캐릭터 이름으로 치환    │
├─────────────────────────────────────┤
│  고정 로어북 항목                      │
└─────────────────────────────────────┘
```

### contents (동적 레이어, 매 턴 생성)

매번 유저가 메시지를 보낼 때마다 새로 만드는 부분:

```
┌─────────────────────────────────────┐
│  유저 페르소나 (이름, 나이, 성별, 설명) │
├─────────────────────────────────────┤
│  캐릭터 기억 (관계 + 시맨틱 메모리)     │
├─────────────────────────────────────┤
│  이전 대화 요약 (장기 기억)             │
├─────────────────────────────────────┤
│  디렉터 노트 (Pro 분석, 선택적)        │
├─────────────────────────────────────┤
│  현재 장면 (위치, 시간, 등장인물)       │
├─────────────────────────────────────┤
│  대화 히스토리 (선택적 or 최근)        │
├─────────────────────────────────────┤
│  유저의 현재 메시지                    │
└─────────────────────────────────────┘
```

---

## ④ Gemini API 스트리밍 호출 — "AI야, 답변해줘!"

**파일:** `src/lib/gemini.ts` → `generateStoryResponseStream()`

### 모델 설정

| 항목 | 값 |
|------|------|
| 모델 | `gemini-2.5-flash` |
| temperature | 0.85 (창의적이되 너무 랜덤하지 않게) |
| topP / topK | 0.9 / 40 |
| 최대 출력 | 8,192 토큰 |
| 응답 형식 | JSON (구조화된 응답) |
| 사고 예산 | 1,024 토큰 (내부 추론용) |

### 응답 스키마

AI가 반드시 이 형식으로 답변해야 해:

```json
{
  "turns": [
    {
      "type": "narrator 또는 dialogue",
      "character": "캐릭터이름",
      "content": "2~4문장의 대사 또는 묘사",
      "emotion": "표정 (neutral/smile/cold/angry/sad/happy/surprised/embarrassed)",
      "emotionIntensity": 0.0 ~ 1.0
    }
  ],
  "scene": {
    "location": "현재 위치",
    "time": "현재 시간",
    "presentCharacters": ["이름1", "이름2"]
  },
  "extractedFacts": ["직업: 대학생", "취미: 게임"]
}
```

### 스트리밍 파싱

응답이 **한 번에 오는 게 아니라 조각조각** 와. `extractNewTurnsFromBuffer()`가 JSON 중괄호 깊이를 추적하면서, 완성된 턴을 발견하면 바로 클라이언트에 전송해.

### 실패 시 대응

| 상황 | 처리 방법 |
|------|-----------|
| 토큰 초과로 잘린 응답 | `repairTruncatedJson()`으로 부분 턴 추출 |
| JSON 파싱 실패 | `parseMarkdownFallback()`로 마크다운 포맷 파싱 |

---

## ⑤ 응답 파싱 & DB 저장 — "답변을 저장하고 유저에게 보내자"

**파일:** `src/app/api/chat/route.ts`

스트림에서 이벤트가 올 때마다:

| 이벤트 | 처리 |
|--------|------|
| `turn` (나레이션) | Message 테이블에 저장 → SSE `narrator` 이벤트 전송 |
| `turn` (대사) | Message 테이블에 저장 → SSE `character_response` 이벤트 전송 |
| `scene` | 현재 장면 상태 업데이트 |
| `extractedFacts` | 유저에서 추출한 정보 캡처 |
| `metadata` | 토큰 수, 캐시 히트율, 소요 시간 기록 |

클라이언트는 **SSE(Server-Sent Events)**로 실시간으로 받아서 화면에 표시해.

---

## ⑥ 메모리 후처리 — "이번 대화를 기억에 새기자"

**파일:** `src/lib/narrative-memory.ts` → `processConversationForMemory()`

대화가 끝나면, **말한 캐릭터마다** 메모리 처리가 돌아가:

### 6-1. 관계도 업데이트 (5축 모델)

기본 변화량 (Pro 분석이 없을 때):
- 애정: +1 (감정적인 순간이면 +3)
- 친숙도: +0.5

**친밀도 점수 계산 공식:**
```
intimacyScore = 애정(35%) + 신뢰(25%) + 친숙도(25%) + 존경(15%) - 경쟁심(10%)
```

친밀도 레벨 자동 전환:
```
stranger → acquaintance → friend → close_friend → intimate
```

### 6-2. 유저 팩트 추출 & 충돌 해결

AI가 대화에서 유저 정보를 뽑아내:
- 형식: `"주제: 내용"` (예: `"직업: 대학생"`)
- 부정적 팩트 거부: "모른다", "기억나지 않는다" 같은 건 저장 안 함

**팩트 충돌 해결:**
- 단일값 키 (직업, 나이 등): 새 값으로 교체
- 다중값 키 (취미, 알레르기, 공포증 등): 여러 개 허용

### 6-3. 캐릭터 기억 저장 — 놀라움 기반 필터

모든 기억을 다 저장하면 너무 많아지니까, **"이 기억이 얼마나 새로운가?"**를 평가해:

| 기존 기억과의 유사도 | 처리 방법 |
|---------------------|-----------|
| ≥ 0.90 (거의 같음) | 기존 기억 강화 (A-MEM 방식) |
| 0.75 ~ 0.90 (비슷함) | 20% 감쇠하여 저장하거나 스킵 |
| < 0.75 (새로움!) | **놀라움 보너스 +30%** 중요도로 저장 |

저장되는 기억 정보:
- 원본 이벤트, 해석, 감정 반응
- 기억 유형: 일화적 / 의미적 / 감정적
- 중요도, 키워드

### 6-4. 감정 히스토리

캐릭터의 감정 + 강도를 히스토리에 추가 (최근 10개 유지).

---

## ⑦ 세션 업데이트

**파일:** `src/app/api/chat/route.ts`

| 업데이트 항목 | 내용 |
|--------------|------|
| turnCount | +1 |
| intimacy | +0.1 (최대 10) |
| currentLocation | AI가 응답한 장면의 위치 |
| currentTime | AI가 응답한 장면의 시간 |
| presentCharacters | 장면 + 대사 캐릭터 병합 |
| recentEvents | 요약 추가 (최근 10개 유지) |

---

## ⑧ 백그라운드 작업 (비동기)

메인 응답과는 별도로 백그라운드에서 돌아가는 작업들:

### 매 5턴마다

- **대화 요약 생성** — Flash 모델로 지금까지 대화를 요약
- **기억 통합** — 비슷한 일화적 기억들을 의미적 기억으로 묶기
- **기억 승격** — 3번 이상 언급된 기억은 중요도 업그레이드

### 이미지 생성 (선택적)

**파일:** `src/lib/imageGeneration.ts`

1. 캐시 체크 (나레이션 텍스트 + 캐릭터 이름의 SHA-256 해시, 7일 TTL)
2. 캐릭터 분류: 프로필 이미지 있는 캐릭터 vs 없는 캐릭터 (실루엣)
3. 감정 → 시각적 표현 매핑 (FACS 기반)
4. `gemini-2.5-flash-image` 모델로 애니메이션 스타일 일러스트 생성
5. Vercel Blob Storage에 저장 & 7일 캐싱

---

## 핵심 성능 최적화 포인트

| 최적화 | 설명 |
|--------|------|
| 병렬 처리 | 인증, DB 쿼리, 메모리 검색을 동시에 실행 |
| 스트리밍 응답 | AI 전체 응답을 기다리지 않고 턴 단위로 즉시 전송 |
| 프롬프트 캐싱 | systemInstruction은 같은 작품 내에서 재사용 |
| 선택적 히스토리 | 전체 대화가 아닌 관련 있는 과거 대화만 포함 |
| 이미지 캐싱 | 같은 장면은 7일간 재생성 안 함 |
| 놀라움 필터 | 중복 기억 저장 방지로 스토리지 절약 |
| Fire-and-forget | 메타데이터/임베딩 저장은 응답 후 비동기로 처리 |

---

*이 문서는 코드 분석 기반으로 자동 생성되었습니다.*
